#!/usr/bin/env perl

use strict;
use warnings;
use threads;
use threads::shared;

use Carp;
use Getopt::Long qw(:config posix_default no_ignore_case bundling pass_through);

use FindBin;
use lib ("$FindBin::Bin/PerlLib");

use GFF3_alignment_utils;
use GTF_alignment_utils;
use Fasta_retriever_faidx;
use List::Util qw(min max);
use Gene_obj_indexer;
use Data::Dumper;

use Thread_helper;
use DB_File;

my $help_flag;


my $min_percent_aligned = 90;
my $min_per_id = 95;
my $out_prefix = "pasa_lite";
my $CPU = 2;



my $usage = <<__EOUSAGE__;

#####################################################################

 usage: $0  --genome genome.fasta [opts] Trinity_gmap.gff3 [Cufflinks.gtf ...]


######################################################################################################
#
#  Required:
#
#   --genome <string>                    : genome.fasta
#
#   --transcripts <string>               : transcript fasta files (comma-delimited if multiple)
#
#  Optional:
#
#   --CPU <int>                          : max number of concurrent threads (default: $CPU)
## 
#   --transcribed_is_aligned_orient      : flag, indicating strand-specific and transcripts 
#                                        already oriented accordingly.  (default, not 
#                                        trusting aligned orientation, define transcribed 
#                                        orient based on splicing patterns.)
# 
#
#   --discard_unspliced_transcripts      :flag, any unspliced transcript alignment is set to invalid.
#
#   --out_prefix <string>                : prefix for output file names (default: $out_prefix)
#
#   --min_per_id <float>                 : min average percent identity of an alignment (default: $min_per_id)
#
#   --min_percent_aligned <float>        : min percent of transcript length aligned (default: $min_percent_aligned)
#
#  Note: As is the PASA tradition, spliced transcripts having non-consensus dinucleotide splice sites
#        are  treated as invalid.   (accepted pairs restricted to: GT-AG, GC-AG, and AT-AC)
#
#
######################################################################################################



__EOUSAGE__

    ;


my $genome_fasta;
my $transcribed_is_aligned_orient_flag = 0;
my $require_consensus_splicesites_flag = 0;
my $discard_unspliced_transcripts_flag = 0;
my $transcripts_files;


&GetOptions ( 'h' => \$help_flag,
              'genome=s' => \$genome_fasta,
              'transcripts=s' => \$transcripts_files,
              'require_consensus_splicesites' => \$require_consensus_splicesites_flag,
              'discard_unspliced_transcripts' => \$discard_unspliced_transcripts_flag,
              'transcribed_is_aligned_orient' => \$transcribed_is_aligned_orient_flag,
              'out_prefix=s' => \$out_prefix,
              'CPU=i' => \$CPU,
              'min_per_id=f' => \$min_per_id,
              'min_percent_aligned=f' => \$min_percent_aligned,
    );


my @unrecognized_args = grep { ! /\.(gtf|gff3)$/ } @ARGV;

if (@unrecognized_args) {
    die "Error, don't recognize arguments: [@unrecognized_args] as prog options or gtf, gff3 files... ";
}

my @gxf_files = @ARGV;

print "GXF files: @gxf_files\n";

if ($help_flag) {
    die $usage;
}

unless ($genome_fasta && @gxf_files && $transcripts_files) {
    die $usage;
}


my $invalid_lock : shared;
my $valid_lock : shared;
my $stats_lock : shared;

main: {

    my $tmpdir = $ENV{TMPDIR} || "/tmp";

    my $tmp_db_prefix = "$tmpdir/tmp.$$.inx";
    
    my $alignments_db = "$tmp_db_prefix.cdna_alignments";
    my $scaff_to_cdna_list_index_file = "$tmp_db_prefix.scaff_to_cdnas";
    my $trans_lengths_db = "$tmp_db_prefix.trans_lengths";

    print STDERR "-parsing transcript lengths\n";
    &store_trans_lengths($trans_lengths_db, $transcripts_files);
    

    my @scaffolds = &index_alignments($alignments_db, $scaff_to_cdna_list_index_file, [@gxf_files]);
    #print "scaffolds: @scaffolds\n";
    
    ## Perform validations, assign spliced orientation
    print STDERR "-reading genome: $genome_fasta\n";
    my $fasta_retriever = new Fasta_retriever_faidx($genome_fasta);
    
    ## prep outfiles, flush all filehandles after writes, no buffering since could cause problems w/ threads
    open (my $ofh_invalid_alignments, ">$out_prefix.invalid_alignments.gtf") or die $!;
    my $stdout = select $ofh_invalid_alignments;
    $|=1;
    
    open (my $ofh_valid_alignments, ">$out_prefix.valid_alignments.gtf") or die $!;
    select($ofh_valid_alignments);
    $|=1;
    
    open(my $ofh_align_stats, ">$out_prefix.align_stats.tsv") or die $!;
    select($ofh_align_stats);
    $|=1;
    print $ofh_align_stats join("\t", "cdna_acc", "align_id", "score", "num_segs",
                                "per_id", "per_length",
                                "valid_status",
                                "sum_fails", "splice_fail", "per_id_fail", "per_length_fail",
                                "alignment_token",
                                "errors_txt") . "\n"; # header
    
    select $stdout;
    
           
    my %all_FHs = (invalid => $ofh_invalid_alignments,
                   valid => $ofh_valid_alignments,
                   stats => $ofh_align_stats
                   
        );
    
    my $thread_helper = new Thread_helper($CPU);

    foreach my $scaff (@scaffolds) {
        
        $thread_helper->wait_for_open_thread();

        my $thread = threads->create('validate_transcript_alignments', $scaff, $scaff_to_cdna_list_index_file, 
                                     $trans_lengths_db, $fasta_retriever, $alignments_db, \%all_FHs);
        $thread_helper->add_thread($thread);
    }
    
    $thread_helper->wait_for_all_threads_to_complete();
    
    # close ofhs
    foreach my $ofh (values %all_FHs) {
        close $ofh;
    }
    
    unlink($alignments_db);
    unlink($scaff_to_cdna_list_index_file);
    unlink($trans_lengths_db);
    
    my @failures = $thread_helper->get_failed_threads();
        
    if (@failures) {
        
        use Data::Dumper;
        print STDERR "Failed threads: " . Dumper(\@failures);
        
        die " errors encountered ";
        
    }
    else {
        print STDERR "\nAlignment validations complete. :)  \n\n";
    }
    
        
    exit(0);
    
    
}



####
sub validate_transcript_alignments {
    my ($scaff, $scaff_to_cdna_list_index_file, $trans_lengths_db, $fasta_retriever, $alignments_db, $all_FHs_href) = @_;

    my %cdnas_idx;
    tie (%cdnas_idx, 'DB_File', $scaff_to_cdna_list_index_file, O_RDONLY, 0, $DB_BTREE);
    
    my %trans_lengths;
    tie (%trans_lengths, 'DB_File', $trans_lengths_db, O_RDONLY, 0, $DB_BTREE);
    
    my $cdna_ids = $cdnas_idx{$scaff};
    my @cdna_ids_list = split(/$;/, $cdna_ids);
    my $cdna_ids_aref = \@cdna_ids_list;
    
    
    my $genome_seq = $fasta_retriever->get_seq($scaff);
    
    print STDERR "-validating transcript alignments on scaffold: $scaff\n";
    
    my $cdna_alignments_indexer = new Gene_obj_indexer( { 'use' => $alignments_db } );
    
    

    my $invalid_fh = $all_FHs_href->{invalid};
    my $valid_fh = $all_FHs_href->{valid};
    my $stats_fh = $all_FHs_href->{stats};
    
    foreach my $cdna_alignment_id (@$cdna_ids_aref) {

        my $cdna_alignment_obj = $cdna_alignments_indexer->get_gene($cdna_alignment_id);
        
        #print Dumper($cdna_alignment_obj);
        #die;

        my $cdna_acc = $cdna_alignment_obj->{gene_id} or confess "Error, no gene set for $cdna_alignment_id object"; 
        
        my $cdna_length = $trans_lengths{$cdna_acc} or confess "Error, no transcript length found for: $cdna_acc";
        
        $cdna_alignment_obj->{cdna_length} = $cdna_length;

        if ($transcribed_is_aligned_orient_flag) {
            $cdna_alignment_obj->set_spliced_orientation( $cdna_alignment_obj->get_aligned_orientation() );
        }
        
        my $SPLICE_FAIL = 0;
        
        my $num_segments = $cdna_alignment_obj->get_num_segments();
        
        if ($num_segments > 1) {
            
            ## Multi-exon transcripts

            $cdna_alignment_obj->identify_splice_junctions(\$genome_seq);
            
            ## ensure proper transcribed orientation in the outputted gtf file
            #  flip it if the splice sites indicate the sequence is reverse-complemented wrt strand 
            if ($cdna_alignment_obj->get_spliced_orientation() =~ /[\+\-]/ 
                &&
                $cdna_alignment_obj->get_spliced_orientation() ne $cdna_alignment_obj->get_aligned_orientation()) {
                
                $cdna_alignment_obj->remap_cdna_segment_coords();
            }
            
            if ($cdna_alignment_obj->get_error_flag()) {
                $SPLICE_FAIL = 1;
            }
            
        }
        else {
            # single-exon alignment
            if ($discard_unspliced_transcripts_flag) {
                $cdna_alignment_obj->set_error_flag("single-segment alignment invalid due to --discard_unspliced_transcripts param set");
            }
        }

        # check percent identity
        
        my $PER_ID_FAIL = 0;
        my $per_id = $cdna_alignment_obj->get_avg_per_id();
        if (defined($per_id) && $per_id < $min_per_id) {
            $cdna_alignment_obj->set_error_flag($cdna_alignment_obj->get_error_flag() . "; avg per_id $per_id < min required ($min_per_id)");
            $PER_ID_FAIL = 1;
        }

        # check alignment percent length
        $cdna_alignment_obj->determine_alignment_attributes();
        my $percent_length = $cdna_alignment_obj->{percent_cdna_aligned};
        
        my $PER_LENGTH_FAIL = 0;
        if ($percent_length < $min_percent_aligned) {
            $cdna_alignment_obj->set_error_flag($cdna_alignment_obj->get_error_flag() . "; percent aligned ($percent_length) < min required ($min_percent_aligned)");
            $PER_LENGTH_FAIL = 1;
        }
        
        my $alignment_score = $percent_length /100 * $cdna_length * $per_id;
        
        
        
        #######################
        ## Output to gtf files
        #######################
        
        
        my $alignment_token =  $cdna_alignment_obj->toToken();
        
        my $alignment_valid_status = "VALID";

        my $errors_text;
        if ($errors_text = $cdna_alignment_obj->get_error_flag()) {
            # report in invalid set
            lock $invalid_lock;
            
            print $invalid_fh "# $cdna_acc " . $alignment_token . " ERROR: $errors_text\n"
                . $cdna_alignment_obj->to_GTF_format(gene_id => $cdna_acc, source => $cdna_alignment_obj->{source}) . "\n";
            
            $alignment_valid_status = "error";
        }
        else {
            
            lock $valid_lock;
            
            print $valid_fh "# $cdna_acc " . $alignment_token . "\n"
                . $cdna_alignment_obj->to_GTF_format(gene_id => $cdna_acc, source => $cdna_alignment_obj->{source}) . "\n";
            
            $errors_text = ".";
        }

        
        my $sum_fails = $SPLICE_FAIL + $PER_ID_FAIL + $PER_LENGTH_FAIL;
        
        $errors_text =~ s/\s+/_/g;
        $alignment_token =~ s/\s+/_/g;
        
        my $stats_line = join("\t", $cdna_acc, $cdna_alignment_id, $alignment_score, $num_segments,
                                 $per_id, sprintf("%.1f", $percent_length),
                                 $alignment_valid_status, 
                                 $sum_fails, $SPLICE_FAIL, $PER_ID_FAIL, $PER_LENGTH_FAIL,
                                 $alignment_token, 
                                 $errors_text);
        
        if ($alignment_valid_status eq "VALID" && $sum_fails > 0) {
            confess "Error, supposed valid status but encountered failures:   $stats_line";
        }
        
        {
            lock $stats_lock;
            
            print $stats_fh "$stats_line\n";
            
        }
    }
    
    return;
    
}



####
sub add_cdna_alignments {
    my ($gxf_file, $cdna_alignments_href, $scaff_to_cdna_list_href) = @_;
    
    my %local_scaff_to_gene_list;

    if ($gxf_file =~ /\.gtf$/i) {
        %local_scaff_to_gene_list = &GTF_alignment_utils::index_alignment_objs($gxf_file, $cdna_alignments_href);
    }
    elsif ($gxf_file =~ /\.gff3$/i) {
        %local_scaff_to_gene_list = &GFF3_alignment_utils::index_alignment_objs($gxf_file, $cdna_alignments_href);
    }

    ## tack them on to our master list
    foreach my $scaff (keys %local_scaff_to_gene_list) {
        my @ids = @{$local_scaff_to_gene_list{$scaff}};
        
        push (@{$scaff_to_cdna_list_href->{$scaff}}, @ids);
    }
    
    return;
}
        

####
sub cluster_transcripts {
    my ($cdna_ids_aref, $cdna_alignments_href) = @_;

    my $overlap_piler = new Overlap_piler();
    
    foreach my $cdna_acc (@$cdna_ids_aref) {
        
        my $alignment_obj = $cdna_alignments_href->{$cdna_acc};
        
        my @segments = $alignment_obj->get_alignment_segments();
        foreach my $segment (@segments) {
            my ($lend, $rend) = $segment->get_coords();
            $overlap_piler->add_coordSet($cdna_acc, $lend, $rend);
        }
    }

    my @clustered_accs = $overlap_piler->build_clusters();

    
    my @pairs;
    
    foreach my $cluster (@clustered_accs) {
        for (my $i = 1; $i <= $#$cluster; $i++) {
            my $prev = $cluster->[$i-1];
            my $curr = $cluster->[$i];
            
            push (@pairs, [$prev, $curr]);
        }
    }

    my @sl_clusters = &SingleLinkageClusterer::build_clusters(@pairs);
    
    return(@sl_clusters);
}


####
sub store_trans_lengths {
    my ($trans_lengths_db, $transcripts_files) = @_;
    
    my %trans_lengths;
    tie (%trans_lengths, 'DB_File', $trans_lengths_db, O_CREAT|O_RDWR, 0666, $DB_BTREE); 
    
    my @transcript_files_list = split(/,/, $transcripts_files);
    
    foreach my $transcript_file (@transcript_files_list) {
        
        my $fai_file = "$transcript_file.fai";
        if (! -s $fai_file) {
            my $ret = system("samtools faidx $transcript_file");
            if ($ret) {
                confess "Error, samtools faidx $transcript_file  died with ret $ret";
            }
        }
        open(my $fh, $fai_file) or confess "Error, cannot open file: $fai_file";
        while(<$fh>) {
            chomp;
            my ($transcript_id, $seq_len, @rest) = split(/\t/);
            $trans_lengths{$transcript_id} = $seq_len;
        }
    }
    
    untie(%trans_lengths);
    
    return;
}


####
sub index_alignments {
    my ($alignments_db, $scaff_to_cdna_list_index_file, $gxf_files_aref) = @_;
    
    print STDERR "-indexing cdna alignments from files: [@$gxf_files_aref]\n";
    my %scaff_to_cdna_list;
    
    my $cdna_alignments_indexer = new Gene_obj_indexer( { create => $alignments_db } );
    
    foreach my $gxf_file (@$gxf_files_aref) {
        
        if (! -e $gxf_file) {
            die "Error, cannot find file: $gxf_file";
        }
        if (-s $gxf_file) {
            print STDERR "-parsing $gxf_file\n";
            &add_cdna_alignments($gxf_file, $cdna_alignments_indexer, \%scaff_to_cdna_list);
        }
    }
    
    my @scaffolds = keys %scaff_to_cdna_list;
    
    my %scaff_to_cdna_list_txt;
    tie (%scaff_to_cdna_list_txt, 'DB_File', $scaff_to_cdna_list_index_file, O_CREAT|O_RDWR, 0666, $DB_BTREE);
    for my $scaff (keys %scaff_to_cdna_list) {
        my @cdnas = @{$scaff_to_cdna_list{$scaff}};
        $scaff_to_cdna_list_txt{$scaff} = join("$;", @cdnas);
    }
    %scaff_to_cdna_list = (); # clear
    untie(%scaff_to_cdna_list_txt);
    

    return @scaffolds;

}
    
